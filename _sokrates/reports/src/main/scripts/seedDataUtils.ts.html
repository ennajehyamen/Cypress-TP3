<html>
<head>
    <title>scripts/seedDataUtils.ts</title>
    <style type="text/css" media="screen">
        #editor {
            position: absolute;
            top: 40px;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">scripts/seedDataUtils.ts (<b>505</b> lines of code) (<a href="seedDataUtils.ts">raw</a>):</h3>
<div id="editor">require(&quot;dotenv&quot;).config();

import shortid from &quot;shortid&quot;;
import { faker } from &quot;@faker-js/faker&quot;;
import bcrypt from &quot;bcryptjs&quot;;
import {
  map,
  flattenDeep,
  times,
  concat,
  sample,
  reject,
  uniqBy,
  flow,
  get,
  curry,
  filter,
  isEqual,
  flattenDepth,
  negate,
  find,
  intersectionWith,
  compact,
  differenceBy,
  sampleSize,
} from &quot;lodash/fp&quot;;
import {
  BankAccount,
  User,
  DefaultPrivacyLevel,
  Like,
  Comment,
  PaymentNotification,
  NotificationType,
  LikeNotification,
  CommentNotification,
  Transaction,
  TransactionStatus,
  TransactionRequestStatus,
  TransactionScenario,
  FakeTransaction,
  Contact,
  BankTransferType,
  BankTransfer,
  PaymentNotificationStatus,
} from &quot;../src/models&quot;;
import { getFakeAmount } from &quot;../src/utils/transactionUtils&quot;;

export const userbaseSize = +process.env.SEED_USERBASE_SIZE!;
export const contactsPerUser = +process.env.SEED_CONTACTS_PER_USER!;
export const paymentsPerUser = +process.env.SEED_PAYMENTS_PER_USER!;
export const requestsPerUser = +process.env.SEED_REQUESTS_PER_USER!;
export const bankAccountsPerUser = +process.env.SEED_BANK_ACCOUNTS_PER_USER!;
export const likesPerUser = +process.env.SEED_LIKES_PER_USER!;
export const commentsPerUser = +process.env.SEED_COMMENTS_PER_USER!;
export const notificationsPerUser = +process.env.SEED_NOTIFICATIONS_PER_USER!;
export const bankTransfersPerUser = +process.env.SEED_BANK_TRANSFERS_PER_USER!;
export const defaultPassword = process.env.SEED_DEFAULT_USER_PASSWORD!;

export const paymentVariations = 2;
export const requestVariations = 3;
// transactions per user = paymentsPerUser * paymentVariations * sender/receiver(2)
// +
// requestsPerUser * requestVariations * sender/receiver(2)
export const transactionsPerUser =
  paymentsPerUser * paymentVariations * 2 + requestsPerUser * requestVariations * 2;
export const totalTransactions = userbaseSize! * transactionsPerUser!;
export const totalLikes = userbaseSize! * likesPerUser!;
export const totalComments = userbaseSize! * commentsPerUser!;
export const totalNotifications = userbaseSize! * notificationsPerUser!;
export const totalContacts = userbaseSize! * contactsPerUser!;
export const totalBankTransfers = userbaseSize! * bankTransfersPerUser * 2; // deposit &amp; withdrawal

export const isPayment = (type: string) =&gt; type === &quot;payment&quot;;
export const passwordHash = bcrypt.hashSync(defaultPassword, 10);

const requestScenarios: TransactionScenario[] = [
  {
    status: TransactionStatus.pending,
    requestStatus: &quot;pending&quot;,
  },
  {
    status: TransactionStatus.complete,
    requestStatus: &quot;accepted&quot;,
  },
  {
    status: TransactionStatus.complete,
    requestStatus: &quot;rejected&quot;,
  },
];

const paymentScenarios: TransactionScenario[] = [
  {
    status: TransactionStatus.pending,
    requestStatus: &quot;&quot;,
  },
  {
    status: TransactionStatus.complete,
    requestStatus: &quot;&quot;,
  },
];

export const getRandomTransactions = (baseCount: number, baseTransactions: Transaction[]) =&gt;
  compact(
    uniqBy(
      &quot;id&quot;,
      times(() =&gt; sample(baseTransactions), baseCount * 3)
    )
  ).slice(0, baseCount);

export const getUserAvatar = (identifier: string) =&gt; {
  return `https://avatars.dicebear.com/api/human/${identifier}.svg`;
};

export const createFakeUser = (): User =&gt; {
  const id = shortid();
  return {
    id,
    uuid: faker.random.uuid(),
    firstName: faker.name.firstName(),
    lastName: faker.name.lastName(),
    username: faker.internet.userName(),
    password: passwordHash,
    email: faker.internet.email(),
    phoneNumber: faker.phone.phoneNumberFormat(0),
    avatar: getUserAvatar(id),
    defaultPrivacyLevel: faker.helpers.randomize([
      DefaultPrivacyLevel.public,
      DefaultPrivacyLevel.private,
      DefaultPrivacyLevel.contacts,
    ]),
    balance: faker.random.number({ min: 10000, max: 200000 }),
    createdAt: faker.date.past(),
    modifiedAt: faker.date.recent(),
  };
};

// @ts-ignore
export const createSeedUsers = () =&gt; times(() =&gt; createFakeUser(), userbaseSize);

export const createContact = (userId: User[&quot;id&quot;], contactUserId: User[&quot;id&quot;]) =&gt; ({
  id: shortid(),
  uuid: faker.random.uuid(),
  userId,
  contactUserId,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

// returns a random user other than the one passed in
export const getOtherRandomUser = curry(
  (seedUsers: User[], userId: User[&quot;id&quot;]): User =&gt; flow(reject([&quot;id&quot;, userId]), sample)(seedUsers)
);

export const randomContactsForUser = curry((seedUsers: User[], user: User) =&gt;
  uniqBy(
    &quot;id&quot;,
    times(() =&gt; getOtherRandomUser(seedUsers, user.id), contactsPerUser * 3)
  ).slice(0, contactsPerUser)
);
export const generateRandomContactsForUser = (seedUsers: User[]) =&gt;
  map((user: User) =&gt; ({
    userId: user.id,
    contacts: randomContactsForUser(seedUsers, user),
  }))(seedUsers);

export const createContactsForUser = curry((randomContacts: any) =&gt;
  flattenDeep(
    map((item: any) =&gt;
      map((contact: User) =&gt; createContact(item.userId, contact.id))(item.contacts)
    )(randomContacts)
  )
);

export const createSeedContacts = (seedUsers: User[]) =&gt; {
  return flow(generateRandomContactsForUser, createContactsForUser)(seedUsers);
};

export const createSeedBankAccounts = (seedUsers: User[]) =&gt;
  map((user: User): BankAccount =&gt; {
    return {
      id: shortid(),
      uuid: faker.random.uuid(),
      userId: user.id,
      bankName: `${faker.company.companyName()} Bank`,
      accountNumber: faker.finance.account(10),
      routingNumber: faker.finance.account(9),
      isDeleted: false,
      createdAt: faker.date.past(),
      modifiedAt: faker.date.recent(),
    };
  })(seedUsers);

// Transactions

export const createTransaction = (
  type: &quot;payment&quot; | &quot;request&quot;,
  account: BankAccount,
  details: FakeTransaction
): Transaction =&gt; {
  const { senderId, receiverId } = details;

  const createdAt = faker.date.past();
  const modifiedAt = faker.date.recent();

  const status = faker.helpers.randomize([TransactionStatus.pending, TransactionStatus.complete]);

  let requestStatus = &quot;&quot;;

  if (type === &quot;request&quot;) {
    requestStatus = TransactionRequestStatus.pending;

    if (status === TransactionStatus.complete) {
      requestStatus = faker.helpers.randomize([
        TransactionRequestStatus.accepted,
        TransactionRequestStatus.rejected,
      ]);
    }
  }

  const requestResolvedAt =
    requestStatus === TransactionRequestStatus.pending
      ? &quot;&quot;
      : faker.date.future(undefined, createdAt);

  return {
    id: shortid(),
    uuid: faker.random.uuid(),
    source: account.id,
    amount: getFakeAmount(),
    description: isPayment(type)
      ? `Payment: ${senderId} to ${receiverId}`
      : `Request: ${receiverId} to ${senderId}`,
    privacyLevel: faker.helpers.randomize([
      DefaultPrivacyLevel.public,
      DefaultPrivacyLevel.private,
      DefaultPrivacyLevel.contacts,
    ]),
    receiverId,
    senderId,
    balanceAtCompletion: getFakeAmount(),
    status,
    requestStatus,
    requestResolvedAt,
    createdAt,
    modifiedAt,
  };
};

export const createPayment = (account: BankAccount, user: User, randomUser: User) =&gt; {
  const allScenarios = paymentScenarios.map((details) =&gt; {
    const paymentTransaction = createTransaction(&quot;payment&quot;, account, {
      senderId: user.id,
      receiverId: randomUser.id,
      ...details,
    });

    const paymentInverseTransaction = createTransaction(&quot;payment&quot;, account, {
      senderId: randomUser.id,
      receiverId: user.id,
      ...details,
    });

    return [paymentTransaction, paymentInverseTransaction];
  });

  return flattenDeep(allScenarios);
};

export const createRequest = (account: BankAccount, user: User, randomUser: User) =&gt; {
  const allScenarios = requestScenarios.map((details) =&gt; {
    const requestTransaction = createTransaction(&quot;request&quot;, account, {
      senderId: user.id,
      receiverId: randomUser.id,
      ...details,
    });

    const requestInverseTransaction = createTransaction(&quot;request&quot;, account, {
      senderId: randomUser.id,
      receiverId: user.id,
      ...details,
    });

    return [requestTransaction, requestInverseTransaction];
  });

  return flattenDeep(allScenarios);
};

export const getBankAccountsByUserId = (
  seedBankAccounts: BankAccount[],
  userId: User[&quot;id&quot;]
): BankAccount[] =&gt; filter(flow(get(&quot;userId&quot;), isEqual(userId)), seedBankAccounts);

export const getTransactionsByUserId = (
  seedTransactions: Transaction[],
  userId: User[&quot;id&quot;]
): Transaction[] =&gt;
  filter(
    ({ senderId, receiverId }) =&gt; isEqual(senderId, userId) || isEqual(receiverId, userId),
    seedTransactions
  );

export const createSeedTransactions = (seedUsers: User[], seedBankAccounts: BankAccount[]) =&gt;
  flattenDepth(
    2,
    map((user: User): Transaction[] =&gt; {
      const accounts = getBankAccountsByUserId(seedBankAccounts, user.id);

      return flattenDepth(
        2,
        map((account: BankAccount): Transaction[] =&gt; {
          const randomUser = getOtherRandomUser(seedUsers, user.id);
          // @ts-ignore
          const payments = times(() =&gt; createPayment(account, user, randomUser), paymentsPerUser);
          // @ts-ignore
          const requests = times(() =&gt; createRequest(account, user, randomUser), requestsPerUser);

          const allScenarios = flattenDeep(concat(payments, requests));
          const requestedTransaction = filter(requestScenarios[0], allScenarios)[0];
          const chargedTransaction = filter(requestScenarios[1], allScenarios)[0];
          const paidTransaction = filter(paymentScenarios[1], allScenarios)[0];

          const testTransactions = [paidTransaction, requestedTransaction, chargedTransaction];

          const remainingScenarios = differenceBy(get(&quot;id&quot;), allScenarios, testTransactions);

          // @ts-ignore
          return flattenDeep(concat(testTransactions, remainingScenarios));
        })(accounts)
      );
    })(seedUsers)
  );

export const createFakeLike = (userId: string, transactionId: string): Like =&gt; ({
  id: shortid(),
  uuid: faker.random.uuid(),
  userId,
  transactionId,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

export const getPublicTransactionsForOtherUsers = (
  seedTransactions: Transaction[],
  userId: User[&quot;id&quot;]
): Transaction[] =&gt;
  flow(
    filter({ privacyLevel: DefaultPrivacyLevel.public }),
    filter(flow(get(&quot;senderId&quot;), negate(isEqual(userId)))),
    filter(flow(get(&quot;receiverId&quot;), negate(isEqual(userId))))
  )(seedTransactions);

export const createSeedLikes = (seedUsers: User[], seedTransactions: Transaction[]) =&gt;
  flattenDeep(
    map((user: User): Like[] =&gt; {
      const transactions = getPublicTransactionsForOtherUsers(seedTransactions, user.id);

      // choose random transactions
      const randomTransactions = getRandomTransactions(10, transactions);

      // get a slice of random transactions
      const selectedTransactions = sampleSize(
        likesPerUser,
        compact(randomTransactions.slice(0, likesPerUser * 2))
      );

      // iterate over transactions and like
      return selectedTransactions.map((transaction) =&gt; createFakeLike(user.id, transaction!.id));
    })(seedUsers)
  );

export const createFakeComment = (userId: string, transactionId: string): Comment =&gt; ({
  id: shortid(),
  uuid: faker.random.uuid(),
  content: faker.lorem.words(),
  userId,
  transactionId,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

export const createSeedComments = (seedUsers: User[], seedTransactions: Transaction[]) =&gt;
  flattenDeep(
    map((user: User): Comment[] =&gt; {
      const transactions = getPublicTransactionsForOtherUsers(seedTransactions, user.id);

      // choose random transactions
      const randomTransactions = getRandomTransactions(5, transactions);

      // get a slice of random transactions
      const selectedTransactions = randomTransactions.slice(0, commentsPerUser);

      // iterate over transactions and comment
      return selectedTransactions.map((transaction) =&gt; createFakeComment(user.id, transaction!.id));
    })(seedUsers)
  );

export const createFakePaymentNotification = (
  userId: string,
  transaction: Transaction,
  status: PaymentNotificationStatus
): PaymentNotification =&gt; ({
  id: shortid(),
  uuid: faker.random.uuid(),
  userId,
  transactionId: transaction.id,
  status,
  isRead: false,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

export const createFakeLikeNotification = (
  userId: string,
  transactionId: string,
  likeId: string
): LikeNotification =&gt; ({
  id: shortid(),
  uuid: faker.random.uuid(),
  userId,
  likeId,
  transactionId,
  isRead: false,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

export const createFakeCommentNotification = (
  userId: string,
  transactionId: string,
  commentId: string
): CommentNotification =&gt; ({
  id: shortid(),
  uuid: faker.random.uuid(),
  userId,
  commentId,
  transactionId,
  isRead: false,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

const getTransactionsWithLikes = (transactions: Transaction[], seedLikes: Like[]) =&gt;
  intersectionWith(
    ({ id: transactionId }, { transactionId: likeTransactionId }) =&gt;
      isEqual(transactionId, likeTransactionId),
    transactions,
    seedLikes
  );

const getLikeByTransactionId = (transactionId: Transaction[&quot;id&quot;], seedLikes: Like[]) =&gt;
  find({ transactionId }, seedLikes) as Like;

const getTransactionsWithComments = (transactions: Transaction[], seedComments: Comment[]) =&gt;
  intersectionWith(
    ({ id: transactionId }, { transactionId: commentTransactionId }) =&gt;
      isEqual(transactionId, commentTransactionId),
    transactions,
    seedComments
  );

const getCommentByTransactionId = (transactionId: Transaction[&quot;id&quot;], seedComments: Comment[]) =&gt;
  find({ transactionId }, seedComments) as Comment;

export const createSeedNotifications = (
  seedUsers: User[],
  seedTransactions: Transaction[],
  seedLikes: Like[],
  seedComments: Comment[]
) =&gt;
  flattenDeep(
    map((user: User): NotificationType[] =&gt; {
      const transactions = getPublicTransactionsForOtherUsers(seedTransactions, user.id);

      const transactionsWithLikes = getTransactionsWithLikes(transactions, seedLikes);

      const transactionsWithComments = getTransactionsWithComments(transactions, seedComments);

      const likeTransaction = sample(compact(getRandomTransactions(5, transactionsWithLikes)));
      const like = getLikeByTransactionId(likeTransaction!.id, seedLikes);
      const likeNotification = createFakeLikeNotification(user.id, likeTransaction!.id, like!.id);

      const commentTransaction = sample(
        compact(getRandomTransactions(5, transactionsWithComments))
      );
      const comment = getCommentByTransactionId(commentTransaction!.id, seedComments);
      // comment notification
      const commentNotification = createFakeCommentNotification(
        user.id,
        commentTransaction!.id,
        comment!.id
      );

      // choose random transactions
      const randomTransactions = getRandomTransactions(notificationsPerUser - 2, transactions);

      const paymentRequestNotifications = randomTransactions.map((transaction) =&gt;
        createFakePaymentNotification(user.id, transaction!, PaymentNotificationStatus.requested)
      );

      const paymentReceivedNotifications = randomTransactions.map((transaction) =&gt;
        createFakePaymentNotification(user.id, transaction!, PaymentNotificationStatus.received)
      );

      let allNotifications = [likeNotification, commentNotification];

      return flattenDeep(
        // @ts-ignore
        concat(allNotifications, [paymentRequestNotifications, paymentReceivedNotifications])
      ) as NotificationType[];
    })(seedUsers)
  );

export const createBankTransfer = (
  transferType: BankTransferType,
  userId: User[&quot;id&quot;],
  transactionId: Transaction[&quot;id&quot;],
  bankAccountId: BankAccount[&quot;id&quot;]
): BankTransfer =&gt; ({
  id: shortid(),
  uuid: faker.random.uuid(),
  userId,
  source: bankAccountId,
  amount: getFakeAmount(),
  type: transferType,
  transactionId,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

export const createSeedBankTransfers = (
  seedUsers: User[],
  seedTransactions: Transaction[],
  seedBankAccounts: BankAccount[]
) =&gt;
  flattenDepth(
    2,
    map((user: User): BankTransfer[] =&gt; {
      const userTransactions: Transaction[] = getTransactionsByUserId(seedTransactions, user.id);
      const bankAccounts = getBankAccountsByUserId(seedBankAccounts, user.id);

      // choose random transactions
      const randomTransactions = getRandomTransactions(
        bankTransfersPerUser,
        userTransactions
      ) as Transaction[];

      return flattenDepth(
        2,
        map((transaction: Transaction): BankTransfer[] =&gt; {
          const deposit = createBankTransfer(
            BankTransferType.deposit,
            user.id,
            transaction.id,
            bankAccounts[0].id
          );
          const withdrawal = createBankTransfer(
            BankTransferType.withdrawal,
            user.id,
            transaction.id,
            bankAccounts[0].id
          );

          return [deposit, withdrawal];
        })(randomTransactions)
      );
    })(seedUsers)
  );

export const buildDatabase = () =&gt; {
  const seedUsers: User[] = createSeedUsers();
  const seedContacts: Contact[] = createSeedContacts(seedUsers);
  const seedBankAccounts: BankAccount[] = createSeedBankAccounts(seedUsers);
  const seedTransactions: Transaction[] = createSeedTransactions(seedUsers, seedBankAccounts);
  const seedLikes: Like[] = createSeedLikes(seedUsers, seedTransactions);
  const seedComments: Comment[] = createSeedComments(seedUsers, seedTransactions);
  const seedNotifications: NotificationType[] = createSeedNotifications(
    seedUsers,
    seedTransactions,
    seedLikes,
    seedComments
  );
  const seedBankTransfers: BankTransfer[] = createSeedBankTransfers(
    seedUsers,
    seedTransactions,
    seedBankAccounts
  );

  return {
    users: seedUsers,
    contacts: seedContacts,
    bankaccounts: seedBankAccounts,
    transactions: seedTransactions,
    likes: seedLikes,
    comments: seedComments,
    notifications: seedNotifications,
    banktransfers: seedBankTransfers,
  };
};
</div>
<script src="https://www.zeljkoobrenovic.com/tools/common/lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/typescript");
    editor.setTheme("ace/theme/xcode");
    editor.setReadOnly(true);
    editor.setOption("wrap", true);
    editor.setPrintMarginColumn(120);
</script>
</body>
