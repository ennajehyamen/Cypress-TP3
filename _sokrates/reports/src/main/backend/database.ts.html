<html>
<head>
    <title>backend/database.ts</title>
    <style type="text/css" media="screen">
        #editor {
            position: absolute;
            top: 40px;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">backend/database.ts (<b>665</b> lines of code) (<a href="database.ts">raw</a>):</h3>
<div id="editor">import path from &quot;path&quot;;
import bcrypt from &quot;bcryptjs&quot;;
import fs from &quot;fs&quot;;
import { v4 } from &quot;uuid&quot;;
import {
  uniqBy,
  map,
  sample,
  reject,
  includes,
  orderBy,
  flow,
  flatMap,
  curry,
  get,
  constant,
  filter,
  inRange,
  remove,
} from &quot;lodash/fp&quot;;
import { isWithinInterval } from &quot;date-fns&quot;;
import low from &quot;lowdb&quot;;
import FileSync from &quot;lowdb/adapters/FileSync&quot;;
import shortid from &quot;shortid&quot;;
import {
  BankAccount,
  Transaction,
  User,
  Contact,
  TransactionStatus,
  TransactionRequestStatus,
  Like,
  Comment,
  PaymentNotification,
  PaymentNotificationStatus,
  LikeNotification,
  CommentNotification,
  NotificationType,
  NotificationPayloadType,
  NotificationsType,
  TransactionResponseItem,
  TransactionPayload,
  BankTransfer,
  BankTransferPayload,
  BankTransferType,
  NotificationResponseItem,
  TransactionQueryPayload,
  DefaultPrivacyLevel,
} from &quot;../src/models&quot;;
import Fuse from &quot;fuse.js&quot;;
import {
  isPayment,
  getTransferAmount,
  hasSufficientFunds,
  getChargeAmount,
  hasDateQueryFields,
  getDateQueryFields,
  hasAmountQueryFields,
  getAmountQueryFields,
  getQueryWithoutFilterFields,
  getPayAppCreditedAmount,
  isRequestTransaction,
  formatFullName,
  isLikeNotification,
  isCommentNotification,
} from &quot;../src/utils/transactionUtils&quot;;
import { DbSchema } from &quot;../src/models/db-schema&quot;;

export type TDatabase = {
  users: User[];
  contacts: Contact[];
  bankaccounts: BankAccount[];
  transactions: Transaction[];
  likes: Like[];
  comments: Comment[];
  notifications: NotificationType[];
  banktransfers: BankTransfer[];
};

const USER_TABLE = &quot;users&quot;;
const CONTACT_TABLE = &quot;contacts&quot;;
const BANK_ACCOUNT_TABLE = &quot;bankaccounts&quot;;
const TRANSACTION_TABLE = &quot;transactions&quot;;
const LIKE_TABLE = &quot;likes&quot;;
const COMMENT_TABLE = &quot;comments&quot;;
const NOTIFICATION_TABLE = &quot;notifications&quot;;
const BANK_TRANSFER_TABLE = &quot;banktransfers&quot;;

const databaseFile = path.join(__dirname, &quot;../data/database.json&quot;);
const adapter = new FileSync&lt;DbSchema&gt;(databaseFile);

const db = low(adapter);

export const seedDatabase = () =&gt; {
  const testSeed = JSON.parse(
    fs.readFileSync(path.join(process.cwd(), &quot;data&quot;, &quot;database-seed.json&quot;), &quot;utf-8&quot;)
  );

  // seed database with test data
  db.setState(testSeed).write();
  return;
};

export const getAllUsers = () =&gt; db.get(USER_TABLE).value();

export const getAllPublicTransactions = () =&gt;
  db.get(TRANSACTION_TABLE).filter({ privacyLevel: DefaultPrivacyLevel.public }).value();

export const getAllForEntity = (entity: keyof DbSchema) =&gt; db.get(entity).value();

export const getAllBy = (entity: keyof DbSchema, key: string, value: any) =&gt; {
  const result = db
    .get(entity)
    // @ts-ignore
    .filter({ [`${key}`]: value })
    .value();

  return result;
};

export const getBy = (entity: keyof DbSchema, key: string, value: any) =&gt; {
  const result = db
    .get(entity)
    // @ts-ignore
    .find({ [`${key}`]: value })
    .value();

  return result;
};

export const getAllByObj = (entity: keyof DbSchema, query: object) =&gt; {
  const result = db
    .get(entity)
    // @ts-ignore
    .filter(query)
    .value();

  return result;
};

// Search
export const cleanSearchQuery = (query: string) =&gt; query.replace(/[^a-zA-Z0-9]/g, &quot;&quot;);

export const setupSearch = curry((items: object[], options: {}, query: string) =&gt; {
  const fuse = new Fuse(items, options);
  return fuse.search(query);
});

export const performSearch = (items: object[], options: {}, query: string) =&gt;
  flow(
    cleanSearchQuery,
    setupSearch(items, options),
    map((result) =&gt; result.item)
  )(query);

export const searchUsers = (query: string) =&gt; {
  const items = getAllUsers();
  return performSearch(
    items,
    {
      keys: [&quot;firstName&quot;, &quot;lastName&quot;, &quot;username&quot;, &quot;email&quot;, &quot;phoneNumber&quot;],
    },
    query
  ) as User[];
};

export const removeUserFromResults = (userId: User[&quot;id&quot;], results: User[]) =&gt;
  remove({ id: userId }, results);

// convenience methods

// User
export const getUserBy = (key: string, value: any) =&gt; getBy(USER_TABLE, key, value);
export const getUserId = (user: User): string =&gt; user.id;
export const getUserById = (id: string) =&gt; getUserBy(&quot;id&quot;, id);
export const getUserByUsername = (username: string) =&gt; getUserBy(&quot;username&quot;, username);

export const createUser = (userDetails: Partial&lt;User&gt;): User =&gt; {
  const password = bcrypt.hashSync(userDetails.password!, 10);
  const user: User = {
    id: shortid(),
    uuid: v4(),
    firstName: userDetails.firstName!,
    lastName: userDetails.lastName!,
    username: userDetails.username!,
    password,
    email: userDetails.email!,
    phoneNumber: userDetails.phoneNumber!,
    balance: Number(userDetails.balance!) || 0,
    avatar: userDetails.avatar!,
    defaultPrivacyLevel: userDetails.defaultPrivacyLevel!,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  saveUser(user);
  return user;
};

const saveUser = (user: User) =&gt; {
  db.get(USER_TABLE).push(user).write();
};

export const updateUserById = (userId: string, edits: Partial&lt;User&gt;) =&gt; {
  const user = getUserById(userId);

  db.get(USER_TABLE).find(user).assign(edits).write();
};

// Contact
export const getContactBy = (key: string, value: any) =&gt; getBy(CONTACT_TABLE, key, value);

export const getContactsBy = (key: string, value: any) =&gt; getAllBy(CONTACT_TABLE, key, value);

export const getContactsByUsername = (username: string) =&gt;
  flow(getUserByUsername, getUserId, getContactsByUserId)(username);

export const getContactsByUserId = (userId: string): Contact[] =&gt; getContactsBy(&quot;userId&quot;, userId);

export const createContact = (contact: Contact) =&gt; {
  db.get(CONTACT_TABLE).push(contact).write();

  // manual lookup after create
  return getContactBy(&quot;id&quot;, contact.id);
};

export const removeContactById = (contactId: string) =&gt; {
  const contact = getContactBy(&quot;id&quot;, contactId);

  db.get(CONTACT_TABLE).remove(contact).write();
};

export const createContactForUser = (userId: string, contactUserId: string) =&gt; {
  const contactId = shortid();
  const contact: Contact = {
    id: contactId,
    uuid: v4(),
    userId,
    contactUserId,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  // Write contact record to the database
  const result = createContact(contact);

  return result;
};

// Bank Account
export const getBankAccountBy = (key: string, value: any) =&gt; getBy(BANK_ACCOUNT_TABLE, key, value);

export const getBankAccountById = (id: string) =&gt; getBankAccountBy(&quot;id&quot;, id);

export const getBankAccountsBy = (key: string, value: any) =&gt;
  getAllBy(BANK_ACCOUNT_TABLE, key, value);

export const createBankAccount = (bankaccount: BankAccount) =&gt; {
  db.get(BANK_ACCOUNT_TABLE).push(bankaccount).write();

  // manual lookup after create
  return getBankAccountBy(&quot;id&quot;, bankaccount.id);
};

export const createBankAccountForUser = (userId: string, accountDetails: Partial&lt;BankAccount&gt;) =&gt; {
  const accountId = shortid();
  const bankaccount: BankAccount = {
    id: accountId,
    uuid: v4(),
    userId,
    bankName: accountDetails.bankName!,
    accountNumber: accountDetails.accountNumber!,
    routingNumber: accountDetails.routingNumber!,
    isDeleted: false,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  // Write bank account record to the database
  const result = createBankAccount(bankaccount);

  return result;
};

export const removeBankAccountById = (bankAccountId: string) =&gt; {
  db.get(BANK_ACCOUNT_TABLE)
    .find({ id: bankAccountId })
    .assign({ isDeleted: true }) // soft delete
    .write();
};

// Bank Transfer
// Note: Balance transfers from/to bank accounts is a future feature,
// but some of the backend database functionality is already implemented here.

/* istanbul ignore next */
export const getBankTransferBy = (key: string, value: any) =&gt;
  getBy(BANK_TRANSFER_TABLE, key, value);

export const getBankTransfersBy = (key: string, value: any) =&gt;
  getAllBy(BANK_TRANSFER_TABLE, key, value);

export const getBankTransfersByUserId = (userId: string) =&gt; getBankTransfersBy(&quot;userId&quot;, userId);

/* istanbul ignore next */
export const createBankTransfer = (bankTransferDetails: BankTransferPayload) =&gt; {
  const bankTransfer: BankTransfer = {
    id: shortid(),
    uuid: v4(),
    ...bankTransferDetails,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  const savedBankTransfer = saveBankTransfer(bankTransfer);
  return savedBankTransfer;
};

/* istanbul ignore next */
const saveBankTransfer = (bankTransfer: BankTransfer): BankTransfer =&gt; {
  db.get(BANK_TRANSFER_TABLE).push(bankTransfer).write();

  // manual lookup after banktransfer created
  return getBankTransferBy(&quot;id&quot;, bankTransfer.id);
};

// Transaction

export const getTransactionBy = (key: string, value: any) =&gt; getBy(TRANSACTION_TABLE, key, value);

export const getTransactionById = (id: string) =&gt; getTransactionBy(&quot;id&quot;, id);

export const getTransactionsByObj = (query: object) =&gt; getAllByObj(TRANSACTION_TABLE, query);

export const getTransactionByIdForApi = (id: string) =&gt;
  formatTransactionForApiResponse(getTransactionBy(&quot;id&quot;, id));

export const getTransactionsForUserForApi = (userId: string, query?: object) =&gt;
  flow(getTransactionsForUserByObj(userId), formatTransactionsForApiResponse)(query);

export const getFullNameForUser = (userId: User[&quot;id&quot;]) =&gt; flow(getUserById, formatFullName)(userId);

export const formatTransactionForApiResponse = (
  transaction: Transaction
): TransactionResponseItem =&gt; {
  const receiver = getUserById(transaction.receiverId);
  const sender = getUserById(transaction.senderId);

  const receiverName = getFullNameForUser(transaction.receiverId);
  const senderName = getFullNameForUser(transaction.senderId);
  const likes = getLikesByTransactionId(transaction.id);
  const comments = getCommentsByTransactionId(transaction.id);

  return {
    receiverName,
    senderName,
    receiverAvatar: receiver.avatar,
    senderAvatar: sender.avatar,
    likes,
    comments,
    ...transaction,
  };
};

export const formatTransactionsForApiResponse = (
  transactions: Transaction[]
): TransactionResponseItem[] =&gt;
  orderBy(
    [(transaction: Transaction) =&gt; new Date(transaction.modifiedAt)],
    [&quot;desc&quot;],
    transactions.map((transaction) =&gt; formatTransactionForApiResponse(transaction))
  );

export const getAllTransactionsForUserByObj = curry((userId: string, query?: object) =&gt; {
  const queryWithoutFilterFields = query &amp;&amp; getQueryWithoutFilterFields(query);

  const queryFields = queryWithoutFilterFields || query;

  const userTransactions = flatMap(getTransactionsByObj)([
    {
      receiverId: userId,
      ...queryFields,
    },
    {
      senderId: userId,
      ...queryFields,
    },
  ]);

  if (query &amp;&amp; (hasDateQueryFields(query) || hasAmountQueryFields(query))) {
    const { dateRangeStart, dateRangeEnd } = getDateQueryFields(query);
    const { amountMin, amountMax } = getAmountQueryFields(query);

    return flow(
      transactionsWithinDateRange(dateRangeStart!, dateRangeEnd!),
      transactionsWithinAmountRange(amountMin!, amountMax!)
    )(userTransactions);
  }
  return userTransactions;
});

export const transactionsWithinAmountRange = curry(
  (amountMin: number, amountMax: number, transactions: Transaction[]) =&gt; {
    if (!amountMin || !amountMax) {
      return transactions;
    }

    return filter(
      (transaction: Transaction) =&gt; inRange(amountMin, amountMax, transaction.amount),
      transactions
    );
  }
);

export const transactionsWithinDateRange = curry(
  (dateRangeStart: string, dateRangeEnd: string, transactions: Transaction[]) =&gt; {
    if (!dateRangeStart || !dateRangeEnd) {
      return transactions;
    }

    return filter(
      (transaction: Transaction) =&gt;
        isWithinInterval(new Date(transaction.createdAt), {
          start: new Date(dateRangeStart),
          end: new Date(dateRangeEnd),
        }),
      transactions
    );
  }
);

export const getTransactionsForUserByObj = curry((userId: string, query: object) =&gt;
  flow(getAllTransactionsForUserByObj(userId), uniqBy(&quot;id&quot;))(query)
);

export const getContactIdsForUser = (userId: string): Contact[&quot;id&quot;][] =&gt;
  flow(getContactsByUserId, map(&quot;contactUserId&quot;))(userId);

export const getTransactionsForUserContacts = (userId: string, query?: object) =&gt;
  uniqBy(
    &quot;id&quot;,
    flatMap(
      (contactId) =&gt; getTransactionsForUserForApi(contactId, query),
      getContactIdsForUser(userId)
    )
  );

export const getTransactionIds = (transactions: Transaction[]) =&gt; map(&quot;id&quot;, transactions);

export const getContactsTransactionIds = (userId: string): Transaction[&quot;id&quot;][] =&gt;
  flow(getTransactionsForUserContacts, getTransactionIds)(userId);

export const nonContactPublicTransactions = (userId: string): Transaction[] =&gt; {
  const contactsTransactionIds = getContactsTransactionIds(userId);
  return flow(
    getAllPublicTransactions,
    reject((transaction: Transaction) =&gt; includes(transaction.id, contactsTransactionIds))
  )();
};

export const getNonContactPublicTransactionsForApi = (userId: string) =&gt;
  flow(nonContactPublicTransactions, formatTransactionsForApiResponse)(userId);

export const getPublicTransactionsDefaultSort = (userId: string) =&gt; ({
  contactsTransactions: getTransactionsForUserContacts(userId),
  publicTransactions: getNonContactPublicTransactionsForApi(userId),
});

export const getPublicTransactionsByQuery = (userId: string, query: TransactionQueryPayload) =&gt; {
  if (query &amp;&amp; (hasDateQueryFields(query) || hasAmountQueryFields(query))) {
    const { dateRangeStart, dateRangeEnd } = getDateQueryFields(query);
    const { amountMin, amountMax } = getAmountQueryFields(query);

    return {
      contactsTransactions: getTransactionsForUserContacts(userId, query),
      publicTransactions: flow(
        transactionsWithinDateRange(dateRangeStart!, dateRangeEnd!),
        transactionsWithinAmountRange(amountMin!, amountMax!)
      )(getNonContactPublicTransactionsForApi(userId)),
    };
  } else {
    return {
      contactsTransactions: getTransactionsForUserContacts(userId),
      publicTransactions: getNonContactPublicTransactionsForApi(userId),
    };
  }
};

export const resetPayAppBalance = constant(0);

export const debitPayAppBalance = (user: User, transaction: Transaction) =&gt; {
  if (hasSufficientFunds(user, transaction)) {
    flow(getChargeAmount, savePayAppBalance(user))(user, transaction);
  } else {
    /* istanbul ignore next */
    flow(
      getTransferAmount(user),
      createBankTransferWithdrawal(user, transaction),
      resetPayAppBalance,
      savePayAppBalance(user)
    )(transaction);
  }
};

export const creditPayAppBalance = (user: User, transaction: Transaction) =&gt;
  flow(getPayAppCreditedAmount, savePayAppBalance(user))(user, transaction);

/* istanbul ignore next */
export const createBankTransferWithdrawal = curry(
  (sender: User, transaction: Transaction, transferAmount: number) =&gt;
    createBankTransfer({
      userId: sender.id,
      source: transaction.source,
      amount: transferAmount,
      transactionId: transaction.id,
      type: BankTransferType.withdrawal,
    })
);

export const savePayAppBalance = curry((sender: User, balance: number) =&gt;
  updateUserById(get(&quot;id&quot;, sender), { balance })
);

export const createTransaction = (
  userId: User[&quot;id&quot;],
  transactionType: &quot;payment&quot; | &quot;request&quot;,
  transactionDetails: TransactionPayload
): Transaction =&gt; {
  const sender = getUserById(userId);
  const receiver = getUserById(transactionDetails.receiverId);
  const transaction: Transaction = {
    id: shortid(),
    uuid: v4(),
    source: transactionDetails.source,
    amount: transactionDetails.amount * 100,
    description: transactionDetails.description,
    receiverId: transactionDetails.receiverId,
    senderId: userId,
    privacyLevel: transactionDetails.privacyLevel || sender.defaultPrivacyLevel,
    status: TransactionStatus.pending,
    requestStatus: transactionType === &quot;request&quot; ? TransactionRequestStatus.pending : undefined,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  const savedTransaction = saveTransaction(transaction);

  // if payment, debit sender's balance for payment amount
  if (isPayment(transaction)) {
    debitPayAppBalance(sender, transaction);
    creditPayAppBalance(receiver, transaction);
    updateTransactionById(transaction.id, {
      status: TransactionStatus.complete,
    });
    createPaymentNotification(
      transaction.receiverId,
      transaction.id,
      PaymentNotificationStatus.received
    );
  } else {
    createPaymentNotification(
      transaction.receiverId,
      transaction.id,
      PaymentNotificationStatus.requested
    );
  }

  return savedTransaction;
};

const saveTransaction = (transaction: Transaction): Transaction =&gt; {
  db.get(TRANSACTION_TABLE).push(transaction).write();

  // manual lookup after transaction created
  return getTransactionBy(&quot;id&quot;, transaction.id);
};

export const updateTransactionById = (transactionId: string, edits: Partial&lt;Transaction&gt;) =&gt; {
  const transaction = getTransactionBy(&quot;id&quot;, transactionId);
  const { senderId, receiverId } = transaction;
  const sender = getUserById(senderId);
  const receiver = getUserById(receiverId);

  // if payment, debit sender's balance for payment amount
  if (isRequestTransaction(transaction)) {
    debitPayAppBalance(receiver, transaction);
    creditPayAppBalance(sender, transaction);
    edits.status = TransactionStatus.complete;

    createPaymentNotification(
      transaction.senderId,
      transaction.id,
      PaymentNotificationStatus.received
    );
  }

  db.get(TRANSACTION_TABLE).find(transaction).assign(edits).write();
};

// Likes

export const getLikeBy = (key: string, value: any): Like =&gt; getBy(LIKE_TABLE, key, value);
export const getLikesByObj = (query: object) =&gt; getAllByObj(LIKE_TABLE, query);

export const getLikeById = (id: string): Like =&gt; getLikeBy(&quot;id&quot;, id);
export const getLikesByTransactionId = (transactionId: string) =&gt; getLikesByObj({ transactionId });

export const createLike = (userId: string, transactionId: string): Like =&gt; {
  const like = {
    id: shortid(),
    uuid: v4(),
    userId,
    transactionId,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  const savedLike = saveLike(like);
  return savedLike;
};

export const createLikes = (userId: string, transactionId: string) =&gt; {
  const { senderId, receiverId } = getTransactionById(transactionId);

  const like = createLike(userId, transactionId);

  /* istanbul ignore next */
  if (userId !== senderId || userId !== receiverId) {
    createLikeNotification(senderId, transactionId, like.id);
    createLikeNotification(receiverId, transactionId, like.id);
  } else if (userId === senderId) {
    createLikeNotification(senderId, transactionId, like.id);
  } else {
    createLikeNotification(receiverId, transactionId, like.id);
  }
};

const saveLike = (like: Like): Like =&gt; {
  db.get(LIKE_TABLE).push(like).write();

  // manual lookup after like created
  return getLikeById(like.id);
};

// Comments

export const getCommentBy = (key: string, value: any): Comment =&gt; getBy(COMMENT_TABLE, key, value);
export const getCommentsByObj = (query: object) =&gt; getAllByObj(COMMENT_TABLE, query);

export const getCommentById = (id: string): Comment =&gt; getCommentBy(&quot;id&quot;, id);
export const getCommentsByTransactionId = (transactionId: string) =&gt;
  getCommentsByObj({ transactionId });

export const createComment = (userId: string, transactionId: string, content: string): Comment =&gt; {
  const comment = {
    id: shortid(),
    uuid: v4(),
    content,
    userId,
    transactionId,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  const savedComment = saveComment(comment);
  return savedComment;
};

export const createComments = (userId: string, transactionId: string, content: string) =&gt; {
  const { senderId, receiverId } = getTransactionById(transactionId);

  const comment = createComment(userId, transactionId, content);

  /* istanbul ignore next */
  if (userId !== senderId || userId !== receiverId) {
    createCommentNotification(senderId, transactionId, comment.id);
    createCommentNotification(receiverId, transactionId, comment.id);
  } else if (userId === senderId) {
    createCommentNotification(senderId, transactionId, comment.id);
  } else {
    createCommentNotification(receiverId, transactionId, comment.id);
  }
};

const saveComment = (comment: Comment): Comment =&gt; {
  db.get(COMMENT_TABLE).push(comment).write();

  // manual lookup after comment created
  return getCommentById(comment.id);
};

// Notifications

export const getNotificationBy = (key: string, value: any): NotificationType =&gt;
  getBy(NOTIFICATION_TABLE, key, value);

export const getNotificationsByObj = (query: object): Notification[] =&gt;
  getAllByObj(NOTIFICATION_TABLE, query);

export const getUnreadNotificationsByUserId = (userId: string) =&gt;
  flow(getNotificationsByObj, formatNotificationsForApiResponse)({ userId, isRead: false });

export const createPaymentNotification = (
  userId: string,
  transactionId: string,
  status: PaymentNotificationStatus
): PaymentNotification =&gt; {
  const notification: PaymentNotification = {
    id: shortid(),
    uuid: v4(),
    userId: userId,
    transactionId: transactionId,
    status,
    isRead: false,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  saveNotification(notification);
  return notification;
};

export const createLikeNotification = (
  userId: string,
  transactionId: string,
  likeId: string
): LikeNotification =&gt; {
  const notification: LikeNotification = {
    id: shortid(),
    uuid: v4(),
    userId: userId,
    transactionId: transactionId,
    likeId: likeId,
    isRead: false,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  saveNotification(notification);
  return notification;
};

export const createCommentNotification = (
  userId: string,
  transactionId: string,
  commentId: string
): CommentNotification =&gt; {
  const notification: CommentNotification = {
    id: shortid(),
    uuid: v4(),
    userId: userId,
    transactionId: transactionId,
    commentId: commentId,
    isRead: false,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  saveNotification(notification);
  return notification;
};

const saveNotification = (notification: NotificationType) =&gt; {
  db.get(NOTIFICATION_TABLE).push(notification).write();
};

export const createNotifications = (userId: string, notifications: NotificationPayloadType[]) =&gt;
  notifications.flatMap((item: NotificationPayloadType) =&gt; {
    if (&quot;status&quot; in item &amp;&amp; item.type === NotificationsType.payment) {
      return createPaymentNotification(userId, item.transactionId, item.status);
    } else if (&quot;likeId&quot; in item &amp;&amp; item.type === NotificationsType.like) {
      return createLikeNotification(userId, item.transactionId, item.likeId);
    } else {
      /* istanbul ignore next */
      if (&quot;commentId&quot; in item) {
        return createCommentNotification(userId, item.transactionId, item.commentId);
      }
    }
  });

export const updateNotificationById = (
  userId: string,
  notificationId: string,
  edits: Partial&lt;NotificationType&gt;
) =&gt; {
  const notification = getNotificationBy(&quot;id&quot;, notificationId);

  db.get(NOTIFICATION_TABLE).find(notification).assign(edits).write();
};

export const formatNotificationForApiResponse = (
  notification: NotificationType
): NotificationResponseItem =&gt; {
  let userFullName = getFullNameForUser(notification.userId);
  const transaction = getTransactionById(notification.transactionId);

  if (isRequestTransaction(transaction)) {
    userFullName = getFullNameForUser(transaction.senderId);
  }

  if (isLikeNotification(notification)) {
    const like = getLikeById(notification.likeId);
    userFullName = getFullNameForUser(like.userId);
  }

  if (isCommentNotification(notification)) {
    const comment = getCommentById(notification.commentId);
    userFullName = getFullNameForUser(comment.userId);
  }

  return {
    userFullName,
    ...notification,
  };
};

export const formatNotificationsForApiResponse = (
  notifications: NotificationResponseItem[]
): NotificationResponseItem[] =&gt;
  orderBy(
    [(notification: NotificationResponseItem) =&gt; new Date(notification.modifiedAt)],
    [&quot;desc&quot;],
    notifications.map((notification) =&gt; formatNotificationForApiResponse(notification))
  );

// dev/test private methods
/* istanbul ignore next */
export const getRandomUser = () =&gt; {
  const users = getAllUsers();
  return sample(users)!;
};

/* istanbul ignore next */
export const getAllContacts = () =&gt; db.get(CONTACT_TABLE).value();

/* istanbul ignore next */
export const getAllTransactions = () =&gt; db.get(TRANSACTION_TABLE).value();

/* istanbul ignore */
export const getBankAccountsByUserId = (userId: string) =&gt; getBankAccountsBy(&quot;userId&quot;, userId);

/* istanbul ignore next */
export const getNotificationById = (id: string): NotificationType =&gt; getNotificationBy(&quot;id&quot;, id);

/* istanbul ignore next */
export const getNotificationsByUserId = (userId: string) =&gt; getNotificationsByObj({ userId });

/* istanbul ignore next */
export const getBankTransferByTransactionId = (transactionId: string) =&gt;
  getBankTransferBy(&quot;transactionId&quot;, transactionId);

/* istanbul ignore next */
export const getTransactionsBy = (key: string, value: string) =&gt;
  getAllBy(TRANSACTION_TABLE, key, value);

/* istanbul ignore next */
export const getTransactionsByUserId = (userId: string) =&gt; getTransactionsBy(&quot;receiverId&quot;, userId);

export default db;
</div>
<script src="https://www.zeljkoobrenovic.com/tools/common/lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/typescript");
    editor.setTheme("ace/theme/xcode");
    editor.setReadOnly(true);
    editor.setOption("wrap", true);
    editor.setPrintMarginColumn(120);
</script>
</body>
